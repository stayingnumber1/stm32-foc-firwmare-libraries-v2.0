###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.30.1.53127/W32 for ARM     04/Nov/2013  13:20:01 #
# Copyright 1999-2011 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  D:\st\stm32 foc firwmare libraries                       #
#                    v2.0\STM32_FOC_PMSM\src\stm32f10x_hall.c                 #
#    Command line =  "D:\st\stm32 foc firwmare libraries                      #
#                    v2.0\STM32_FOC_PMSM\src\stm32f10x_hall.c" -D             #
#                    VECT_TAB_FLASH -lCN "D:\st\stm32 foc firwmare libraries  #
#                    v2.0\STM32_FOC_PMSM\EWARM\Debug\List\" --diag_error      #
#                    Pe068,Pe069 -o "D:\st\stm32 foc firwmare libraries       #
#                    v2.0\STM32_FOC_PMSM\EWARM\Debug\Obj\" --debug            #
#                    --endian=little --cpu=Cortex-M3 --fpu=None               #
#                    --dlib_config D:\IAR\arm\INC\c\DLib_Config_Normal.h -I   #
#                    "D:\st\stm32 foc firwmare libraries                      #
#                    v2.0\STM32_FOC_PMSM\EWARM\..\" -I "D:\st\stm32 foc       #
#                    firwmare libraries v2.0\STM32_FOC_PMSM\EWARM\..\..\STM32 #
#                    F10XFWLIB\inc\" -I "D:\st\stm32 foc firwmare libraries   #
#                    v2.0\STM32_FOC_PMSM\EWARM\..\inc\" -Oh --use_c++_inline  #
#                    --require_prototypes                                     #
#    List file    =  D:\st\stm32 foc firwmare libraries                       #
#                    v2.0\STM32_FOC_PMSM\EWARM\Debug\List\stm32f10x_hall.lst  #
#    Object file  =  D:\st\stm32 foc firwmare libraries                       #
#                    v2.0\STM32_FOC_PMSM\EWARM\Debug\Obj\stm32f10x_hall.o     #
#                                                                             #
#                                                                             #
###############################################################################

D:\st\stm32 foc firwmare libraries v2.0\STM32_FOC_PMSM\src\stm32f10x_hall.c
      1          /******************** (C) COPYRIGHT 2008 STMicroelectronics ********************
      2          * File Name          : stm32f10x_hall.c
      3          * Author             : IMS Systems Lab 
      4          * Date First Issued  : 21/11/07
      5          * Description        : Module handling speed feedback provided by three Hall 
      6          *                      sensors
      7          ********************************************************************************
      8          * History:
      9          * 21/11/07 v1.0
     10          * 29/05/08 v2.0
     11          * 26/06/08 v2.0.1
     12          * 27/06/08 v2.0.2
     13          ********************************************************************************
     14          * THE PRESENT SOFTWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
     15          * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE TIME.
     16          * AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
     17          * INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
     18          * CONTENT OF SUCH SOFTWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
     19          * INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
     20          *
     21          * THIS SOURCE CODE IS PROTECTED BY A LICENSE.
     22          * FOR MORE INFORMATION PLEASE CAREFULLY READ THE LICENSE AGREEMENT FILE LOCATED
     23          * IN THE ROOT DIRECTORY OF THIS FIRMWARE PACKAGE.
     24          *******************************************************************************/
     25          
     26          /* Includes ------------------------------------------------------------------*/
     27          #include "stm32f10x_lib.h"
     28          #include "stm32f10x_hall.h"
     29          #include "MC_hall_prm.h"
     30          #include "MC_Globals.h"
     31          #include "stm32f10x_MClib.h"
     32          #include "stm32f10x_it.h"
     33          /* Private define ------------------------------------------------------------*/
     34          #define HALL_MAX_SPEED_FDBK (u16)(HALL_MAX_SPEED_FDBK_RPM/6 * POLE_PAIR_NUM)
     35          #define HALL_MIN_SPEED_FDBK (u16)(HALL_MIN_SPEED_FDBK_RPM/6* POLE_PAIR_NUM)
     36          #define LOW_RES_THRESHOLD   ((u16)0x5500u)// If capture below, ck prsc decreases
     37          #define	ROTOR_SPEED_FACTOR  ((u32)((CKTIM*10)) / 3)
     38          #define PSEUDO_FREQ_CONV    ((u32)(ROTOR_SPEED_FACTOR / (SAMPLING_FREQ * 10)) * 0x10000uL)
     39          #define SPEED_OVERFLOW      ((u32)(ROTOR_SPEED_FACTOR / HALL_MAX_SPEED_FDBK))
     40          #define MAX_PERIOD          ((u32)(ROTOR_SPEED_FACTOR / HALL_MIN_SPEED_FDBK))
     41          #define HALL_COUNTER_RESET  ((u16) 0)
     42          #define S16_PHASE_SHIFT     (s16)(HALL_PHASE_SHIFT * 65536/360)
     43          #define S16_120_PHASE_SHIFT (s16)(65536/3)
     44          #define S16_60_PHASE_SHIFT  (s16)(65536/6)
     45          
     46          #define STATE_0 (u8)0
     47          #define STATE_1 (u8)1
     48          #define STATE_2 (u8)2
     49          #define STATE_3 (u8)3
     50          #define STATE_4 (u8)4
     51          #define STATE_5 (u8)5
     52          #define STATE_6 (u8)6
     53          #define STATE_7 (u8)7
     54          
     55          #define NEGATIVE          (s8)-1
     56          #define POSITIVE          (s8)1
     57          #define NEGATIVE_SWAP     (s8)-2
     58          #define POSITIVE_SWAP     (s8)2
     59          #define ERROR             (s8)127
     60          
     61          #define GPIO_MSK (u8)0x07
     62          #define ICx_FILTER (u8) 0x0B // 11 <-> 1333 nsec 
     63          
     64          #define TIMx_PRE_EMPTION_PRIORITY 2
     65          #define TIMx_SUB_PRIORITY 0
     66          
     67          /* if (HALL_SENSORS_PLACEMENT == DEGREES_120)
     68          The sequence of the states is {STATE_5,STATE_1,STATE_3,STATE_2,STATE_6,STATE_4}
     69          else if (HALL_SENSORS_PLACEMENT == DEGREES_60)
     70          the sequence is {STATE_1,STATE_3,STATE_7,STATE_6,STATE_4,STATE_0}*/
     71          
     72          // Here is practically assigned the timer for Hall handling
     73          #if defined(TIMER2_HANDLES_HALL)
     74              #define HALL_TIMER TIM2
     75          #elif defined(TIMER3_HANDLES_HALL)
     76              #define HALL_TIMER TIM3
     77          #else // TIMER4_HANDLES_HALL
     78              #define HALL_TIMER TIM4
     79          #endif
     80          
     81          /* Private macro -------------------------------------------------------------*/
     82          /* Private typedef -----------------------------------------------------------*/
     83          typedef struct {
     84          	u16 hCapture;
     85          	u16 hPrscReg;
     86                  s8 bDirection;
     87          	} SpeedMeas_s;
     88          
     89          typedef struct {
     90                  u32 wPeriod;
     91                  s8 bDirection;
     92                  } PeriodMeas_s;
     93          /* Private variables ---------------------------------------------------------*/
     94          

   \                                 In section .bss, align 4
     95          volatile SpeedMeas_s SensorPeriod[HALL_SPEED_FIFO_SIZE];// Holding the last captures
   \                     SensorPeriod:
   \   00000000                      DS8 36
     96          vu8 bSpeedFIFO_Index;   // Index of above array
     97          vu8 bGP1_OVF_Counter;   // Count overflows if prescaler is too low
     98          vu16 hCaptCounter;      // Counts the number of captures interrupts
     99          volatile PeriodMeas_s PeriodMeas;
    100          
    101          volatile bool RatioDec;
    102          volatile bool RatioInc;
    103          volatile bool DoRollingAverage;
    104          volatile bool InitRollingAverage;
    105          volatile bool HallTimeOut;
    106          static s16 hElectrical_Angle; 
    107          static s16 hRotorFreq_dpp;
    108          #if (defined HALL_SENSORS || defined VIEW_HALL_FEEDBACK)
    109          static s8 bSpeed;
    110          #endif
    111          /* Private function prototypes -----------------------------------------------*/
    112          PeriodMeas_s GetLastHallPeriod(void);
    113          PeriodMeas_s GetAvrgHallPeriod(void);
    114          void HALL_StartHallFiltering(void);
    115          u16  HALL_GetCaptCounter(void);
    116          void HALL_ClrCaptCounter(void);
    117          
    118          u8  ReadHallState(void); 
    119          /*******************************************************************************
    120          * Function Name  : Hall_HallTimerInit
    121          * Description    : Initializes the timer handling Hall sensors feedback
    122          * Input          : None
    123          * Output         : None
    124          * Return         : None
    125          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    126          void HALL_HallTimerInit(void)
    127          {
   \                     HALL_HallTimerInit:
   \   00000000   0xB500             PUSH     {LR}
   \   00000002   0xB089             SUB      SP,SP,#+36
    128          
    129            TIM_TimeBaseInitTypeDef TIM_HALLTimeBaseInitStructure;
    130            TIM_ICInitTypeDef       TIM_HALLICInitStructure;
    131            NVIC_InitTypeDef        NVIC_InitHALLStructure;
    132            GPIO_InitTypeDef        GPIO_InitStructure;
    133            
    134          #if defined(TIMER2_HANDLES_HALL)
    135              /* TIM2 clock source enable */
    136              RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM2, ENABLE);
   \   00000004   0x2101             MOVS     R1,#+1
   \   00000006   0x2001             MOVS     R0,#+1
   \   00000008   0x.... 0x....      BL       RCC_APB1PeriphClockCmd
    137              /* Enable GPIOA, clock */
    138              RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE);
   \   0000000C   0x2101             MOVS     R1,#+1
   \   0000000E   0x2004             MOVS     R0,#+4
   \   00000010   0x.... 0x....      BL       RCC_APB2PeriphClockCmd
    139          
    140              GPIO_StructInit(&GPIO_InitStructure);
   \   00000014   0xA801             ADD      R0,SP,#+4
   \   00000016   0x.... 0x....      BL       GPIO_StructInit
    141              /* Configure PA.00,01 ,02 as Hall sensors input */
    142              GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0 | GPIO_Pin_1 | GPIO_Pin_2;
   \   0000001A   0x2007             MOVS     R0,#+7
   \   0000001C   0xF8AD 0x0004      STRH     R0,[SP, #+4]
    143              GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;
   \   00000020   0x2004             MOVS     R0,#+4
   \   00000022   0xF88D 0x0007      STRB     R0,[SP, #+7]
    144              GPIO_Init(GPIOA, &GPIO_InitStructure);
   \   00000026   0xA901             ADD      R1,SP,#+4
   \   00000028   0x....             LDR.N    R0,??DataTable14  ;; 0x40010800
   \   0000002A   0x.... 0x....      BL       GPIO_Init
    145          #elif defined(TIMER3_HANDLES_HALL)
    146              /* TIM3 clock source enable */
    147              RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM3, ENABLE);
    148              /* Enable GPIOA, clock */
    149              RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE);
    150              /* Enable GPIOB, clock */
    151              RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB, ENABLE);
    152          
    153              GPIO_StructInit(&GPIO_InitStructure);
    154              /* Configure PA.06,07  PB.00 as Hall sensors input */
    155              GPIO_InitStructure.GPIO_Pin = GPIO_Pin_6 | GPIO_Pin_7;
    156              GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;
    157              GPIO_Init(GPIOA, &GPIO_InitStructure);
    158          
    159              GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0;
    160              GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;
    161              GPIO_Init(GPIOB, &GPIO_InitStructure);
    162            #else // TIMER4_HANDLES_HALL
    163              /* TIM4 clock source enable */
    164              RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM4, ENABLE);
    165              /* Enable GPIOB, clock */
    166              RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB, ENABLE);
    167              /* Configure PB.06,07,08 as Hall sensors input */	
    168              GPIO_InitStructure.GPIO_Pin = GPIO_Pin_6, GPIO_Pin_7, GPIO_Pin_8;
    169              GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;
    170              GPIO_Init(GPIOB, &GPIO_InitStructure);	
    171            #endif
    172                
    173              // Timer configuration in Clear on capture mode
    174              TIM_DeInit(HALL_TIMER);
   \   0000002E   0xF04F 0x4080      MOV      R0,#+1073741824
   \   00000032   0x.... 0x....      BL       TIM_DeInit
    175              
    176              TIM_TimeBaseStructInit(&TIM_HALLTimeBaseInitStructure);
   \   00000036   0xA805             ADD      R0,SP,#+20
   \   00000038   0x.... 0x....      BL       TIM_TimeBaseStructInit
    177              // Set full 16-bit working range
    178              TIM_HALLTimeBaseInitStructure.TIM_Period = U16_MAX;
   \   0000003C   0xF64F 0x70FF      MOVW     R0,#+65535
   \   00000040   0xF8AD 0x0018      STRH     R0,[SP, #+24]
    179              TIM_HALLTimeBaseInitStructure.TIM_ClockDivision = TIM_CKD_DIV1;
   \   00000044   0x2000             MOVS     R0,#+0
   \   00000046   0xF8AD 0x001A      STRH     R0,[SP, #+26]
    180              TIM_TimeBaseInit(HALL_TIMER,&TIM_HALLTimeBaseInitStructure);
   \   0000004A   0xA905             ADD      R1,SP,#+20
   \   0000004C   0xF04F 0x4080      MOV      R0,#+1073741824
   \   00000050   0x.... 0x....      BL       TIM_TimeBaseInit
    181              
    182              TIM_ICStructInit(&TIM_HALLICInitStructure);
   \   00000054   0xA802             ADD      R0,SP,#+8
   \   00000056   0x.... 0x....      BL       TIM_ICStructInit
    183              TIM_HALLICInitStructure.TIM_Channel = TIM_Channel_1;
   \   0000005A   0x2000             MOVS     R0,#+0
   \   0000005C   0xF8AD 0x0008      STRH     R0,[SP, #+8]
    184              TIM_HALLICInitStructure.TIM_ICPolarity = TIM_ICPolarity_Falling;
   \   00000060   0x2002             MOVS     R0,#+2
   \   00000062   0xF8AD 0x000A      STRH     R0,[SP, #+10]
    185              TIM_HALLICInitStructure.TIM_ICFilter = ICx_FILTER;
   \   00000066   0x200B             MOVS     R0,#+11
   \   00000068   0xF8AD 0x0010      STRH     R0,[SP, #+16]
    186              
    187              TIM_ICInit(HALL_TIMER,&TIM_HALLICInitStructure);
   \   0000006C   0xA902             ADD      R1,SP,#+8
   \   0000006E   0xF04F 0x4080      MOV      R0,#+1073741824
   \   00000072   0x.... 0x....      BL       TIM_ICInit
    188              
    189              // Force the HALL_TIMER prescaler with immediate access (no need of an update event) 
    190              TIM_PrescalerConfig(HALL_TIMER, (u16) HALL_MAX_RATIO, 
    191                                 TIM_PSCReloadMode_Immediate);
   \   00000076   0x2201             MOVS     R2,#+1
   \   00000078   0xF44F 0x7148      MOV      R1,#+800
   \   0000007C   0xF04F 0x4080      MOV      R0,#+1073741824
   \   00000080   0x.... 0x....      BL       TIM_PrescalerConfig
    192              TIM_InternalClockConfig(HALL_TIMER);
   \   00000084   0xF04F 0x4080      MOV      R0,#+1073741824
   \   00000088   0x.... 0x....      BL       TIM_InternalClockConfig
    193              
    194              //Enables the XOR of channel 1, channel2 and channel3
    195              TIM_SelectHallSensor(HALL_TIMER, ENABLE);
   \   0000008C   0x2101             MOVS     R1,#+1
   \   0000008E   0xF04F 0x4080      MOV      R0,#+1073741824
   \   00000092   0x.... 0x....      BL       TIM_SelectHallSensor
    196              
    197              TIM_SelectInputTrigger(HALL_TIMER, TIM_TS_TI1FP1);
   \   00000096   0x2150             MOVS     R1,#+80
   \   00000098   0xF04F 0x4080      MOV      R0,#+1073741824
   \   0000009C   0x.... 0x....      BL       TIM_SelectInputTrigger
    198              TIM_SelectSlaveMode(HALL_TIMER,TIM_SlaveMode_Reset);
   \   000000A0   0x2104             MOVS     R1,#+4
   \   000000A2   0xF04F 0x4080      MOV      R0,#+1073741824
   \   000000A6   0x.... 0x....      BL       TIM_SelectSlaveMode
    199             
    200              // Source of Update event is only counter overflow/underflow
    201              TIM_UpdateRequestConfig(HALL_TIMER, TIM_UpdateSource_Regular);
   \   000000AA   0x2101             MOVS     R1,#+1
   \   000000AC   0xF04F 0x4080      MOV      R0,#+1073741824
   \   000000B0   0x.... 0x....      BL       TIM_UpdateRequestConfig
    202              
    203              /* Enable the HALL_TIMER IRQChannel*/
    204          #if defined(TIMER2_HANDLES_HALL)
    205              NVIC_InitHALLStructure.NVIC_IRQChannel = TIM2_IRQChannel;
   \   000000B4   0x201C             MOVS     R0,#+28
   \   000000B6   0xF88D 0x0000      STRB     R0,[SP, #+0]
    206          #elif defined(TIMER3_HANDLES_HALL)
    207              NVIC_InitHALLStructure.NVIC_IRQChannel = TIM3_IRQChannel;
    208          #else // TIMER4_HANDLES_HALL
    209              NVIC_InitHALLStructure.NVIC_IRQChannel = TIM4_IRQChannel;
    210          #endif
    211            
    212              NVIC_InitHALLStructure.NVIC_IRQChannelPreemptionPriority = 
    213                                                                TIMx_PRE_EMPTION_PRIORITY;
   \   000000BA   0x2002             MOVS     R0,#+2
   \   000000BC   0xF88D 0x0001      STRB     R0,[SP, #+1]
    214              NVIC_InitHALLStructure.NVIC_IRQChannelSubPriority = TIMx_SUB_PRIORITY;
   \   000000C0   0x2000             MOVS     R0,#+0
   \   000000C2   0xF88D 0x0002      STRB     R0,[SP, #+2]
    215              NVIC_InitHALLStructure.NVIC_IRQChannelCmd = ENABLE;
   \   000000C6   0x2001             MOVS     R0,#+1
   \   000000C8   0xF88D 0x0003      STRB     R0,[SP, #+3]
    216              
    217              NVIC_Init(&NVIC_InitHALLStructure);
   \   000000CC   0xA800             ADD      R0,SP,#+0
   \   000000CE   0x.... 0x....      BL       NVIC_Init
    218          
    219              // Clear the TIMx's pending flags
    220              TIM_ClearFlag(HALL_TIMER, TIM_FLAG_Update + TIM_FLAG_CC1 + TIM_FLAG_CC2 + \
    221                            TIM_FLAG_CC3 + TIM_FLAG_CC4 + TIM_FLAG_Trigger + TIM_FLAG_CC1OF + \
    222                            TIM_FLAG_CC2OF + TIM_FLAG_CC3OF + TIM_FLAG_CC4OF);
   \   000000D2   0xF641 0x615F      MOVW     R1,#+7775
   \   000000D6   0xF04F 0x4080      MOV      R0,#+1073741824
   \   000000DA   0x.... 0x....      BL       TIM_ClearFlag
    223            
    224              // Selected input capture and Update (overflow) events generate interrupt
    225              TIM_ITConfig(HALL_TIMER, TIM_IT_CC1, ENABLE);
   \   000000DE   0x2201             MOVS     R2,#+1
   \   000000E0   0x2102             MOVS     R1,#+2
   \   000000E2   0xF04F 0x4080      MOV      R0,#+1073741824
   \   000000E6   0x.... 0x....      BL       TIM_ITConfig
    226              TIM_ITConfig(HALL_TIMER, TIM_IT_Update, ENABLE);
   \   000000EA   0x2201             MOVS     R2,#+1
   \   000000EC   0x4611             MOV      R1,R2
   \   000000EE   0xF04F 0x4080      MOV      R0,#+1073741824
   \   000000F2   0x.... 0x....      BL       TIM_ITConfig
    227          
    228              TIM_SetCounter(HALL_TIMER, HALL_COUNTER_RESET);
   \   000000F6   0x2100             MOVS     R1,#+0
   \   000000F8   0xF04F 0x4080      MOV      R0,#+1073741824
   \   000000FC   0x.... 0x....      BL       TIM_SetCounter
    229                 TIM_Cmd(HALL_TIMER, ENABLE);
   \   00000100   0x2101             MOVS     R1,#+1
   \   00000102   0xF04F 0x4080      MOV      R0,#+1073741824
   \   00000106   0x.... 0x....      BL       TIM_Cmd
    230          }
   \   0000010A   0xB009             ADD      SP,SP,#+36
   \   0000010C   0xBD00             POP      {PC}             ;; return
    231          
    232          
    233          /*******************************************************************************
    234          * ROUTINE Name : HALL_InitHallMeasure
    235          *
    236          * Description : Clear software FIFO where are "pushed" latest speed information
    237          *           This function must be called before starting the motor to initialize
    238          *	    the speed measurement process.
    239          *
    240          * Input       : None
    241          * Output      : None
    242          * Return      : None
    243          * Note        : First measurements following this function call will be done
    244          *               without filtering (no rolling average).
    245          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    246          void HALL_InitHallMeasure( void )
    247          {
   \                     HALL_InitHallMeasure:
   \   00000000   0xB538             PUSH     {R3-R5,LR}
    248             // Mask interrupts to insure a clean intialization
    249          
    250             TIM_ITConfig(HALL_TIMER, TIM_IT_CC1, DISABLE);
   \   00000002   0x2200             MOVS     R2,#+0
   \   00000004   0x2102             MOVS     R1,#+2
   \   00000006   0xF04F 0x4080      MOV      R0,#+1073741824
   \   0000000A   0x.... 0x....      BL       TIM_ITConfig
    251              
    252             RatioDec = FALSE;
   \   0000000E   0x....             LDR.N    R0,??DataTable14_1
   \   00000010   0x2100             MOVS     R1,#+0
   \   00000012   0x7081             STRB     R1,[R0, #+2]
    253             RatioInc = FALSE;
   \   00000014   0x70C1             STRB     R1,[R0, #+3]
    254             DoRollingAverage = FALSE;
   \   00000016   0x7101             STRB     R1,[R0, #+4]
    255             InitRollingAverage = FALSE;
   \   00000018   0x7141             STRB     R1,[R0, #+5]
    256             HallTimeOut = FALSE;
   \   0000001A   0x7181             STRB     R1,[R0, #+6]
    257          
    258             hCaptCounter = 0;
   \   0000001C   0x8101             STRH     R1,[R0, #+8]
    259             bGP1_OVF_Counter = 0;
   \   0000001E   0x7041             STRB     R1,[R0, #+1]
    260          
    261             for (bSpeedFIFO_Index=0; bSpeedFIFO_Index < HALL_SPEED_FIFO_SIZE; 
   \   00000020   0x7001             STRB     R1,[R0, #+0]
   \   00000022   0xF44F 0x7148      MOV      R1,#+800
   \   00000026   0x....             LDR.N    R2,??DataTable14_2
   \   00000028   0xF64F 0x73FF      MOVW     R3,#+65535
   \   0000002C   0xE014             B.N      ??HALL_InitHallMeasure_0
    262                                                                       bSpeedFIFO_Index++)
    263             {
    264                SensorPeriod[bSpeedFIFO_Index].hCapture = U16_MAX;
   \                     ??HALL_InitHallMeasure_1:
   \   0000002E   0x7804             LDRB     R4,[R0, #+0]
   \   00000030   0xEB04 0x0544      ADD      R5,R4,R4, LSL #+1
   \   00000034   0x006C             LSLS     R4,R5,#+1
   \   00000036   0x52A3             STRH     R3,[R4, R2]
    265                SensorPeriod[bSpeedFIFO_Index].hPrscReg = HALL_MAX_RATIO;
   \   00000038   0x7804             LDRB     R4,[R0, #+0]
   \   0000003A   0xEB04 0x0544      ADD      R5,R4,R4, LSL #+1
   \   0000003E   0xEB02 0x0445      ADD      R4,R2,R5, LSL #+1
   \   00000042   0x8061             STRH     R1,[R4, #+2]
    266                SensorPeriod[bSpeedFIFO_Index].bDirection = POSITIVE;
   \   00000044   0x7804             LDRB     R4,[R0, #+0]
   \   00000046   0xEB04 0x0544      ADD      R5,R4,R4, LSL #+1
   \   0000004A   0xEB02 0x0445      ADD      R4,R2,R5, LSL #+1
   \   0000004E   0x2501             MOVS     R5,#+1
   \   00000050   0x7125             STRB     R5,[R4, #+4]
    267             }
   \   00000052   0x7804             LDRB     R4,[R0, #+0]
   \   00000054   0x1C64             ADDS     R4,R4,#+1
   \   00000056   0x7004             STRB     R4,[R0, #+0]
   \                     ??HALL_InitHallMeasure_0:
   \   00000058   0x7804             LDRB     R4,[R0, #+0]
   \   0000005A   0x2C06             CMP      R4,#+6
   \   0000005C   0xD3E7             BCC.N    ??HALL_InitHallMeasure_1
    268          
    269             // First measurement will be stored in the 1st array location
    270             bSpeedFIFO_Index = HALL_SPEED_FIFO_SIZE-1;
   \   0000005E   0x2205             MOVS     R2,#+5
   \   00000060   0x7002             STRB     R2,[R0, #+0]
    271          
    272             // Re-initialize partly the timer
    273             HALL_TIMER->PSC = HALL_MAX_RATIO;
   \   00000062   0xF04F 0x4280      MOV      R2,#+1073741824
   \   00000066   0x8511             STRH     R1,[R2, #+40]
    274             
    275             HALL_ClrCaptCounter();
   \   00000068   0x2100             MOVS     R1,#+0
   \   0000006A   0x8101             STRH     R1,[R0, #+8]
    276               
    277             TIM_SetCounter(HALL_TIMER, HALL_COUNTER_RESET);
   \   0000006C   0x4610             MOV      R0,R2
   \   0000006E   0x.... 0x....      BL       TIM_SetCounter
    278             
    279             TIM_Cmd(HALL_TIMER, ENABLE);
   \   00000072   0x2101             MOVS     R1,#+1
   \   00000074   0xF04F 0x4080      MOV      R0,#+1073741824
   \   00000078   0x.... 0x....      BL       TIM_Cmd
    280          
    281             TIM_ITConfig(HALL_TIMER, TIM_IT_CC1, ENABLE);
   \   0000007C   0x2201             MOVS     R2,#+1
   \   0000007E   0x2102             MOVS     R1,#+2
   \   00000080   0xF04F 0x4080      MOV      R0,#+1073741824
   \   00000084   0xE8BD 0x4038      POP      {R3-R5,LR}
   \   00000088   0x.... 0x....      B.W      TIM_ITConfig
    282          
    283          }
    284          
    285          
    286          /*******************************************************************************
    287          * ROUTINE Name : HALL_GetSpeed
    288          *
    289          * Description : This routine returns Rotor frequency with [0.1Hz] definition.
    290          *		Result is given by the following formula:
    291          *		Frotor = K x (Fosc / (Capture x number of overflow)))
    292          *		where K depends on the number of motor poles pairs
    293          *
    294          * Input    : None
    295          * Output   : None
    296          * Returns  : Rotor mechanical frequency, with 0.1Hz resolution.
    297          * Comments : Result is zero if speed is too low (glitches at start for instance)
    298          *           Excessive speed (or high freq glitches will result in a pre-defined
    299          *           value returned.
    300          * Warning : Maximum expectable accuracy depends on CKTIM: 72MHz will give the
    301          * 	    best results.
    302          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    303          s16 HALL_GetSpeed ( void )
    304          { 
   \                     HALL_GetSpeed:
   \   00000000   0x....             LDR.N    R0,??DataTable14_1
   \   00000002   0xF9B0 0x000C      LDRSH    R0,[R0, #+12]
   \   00000006   0x....             LDR.N    R1,??DataTable14_3  ;; 0xffff8000
   \   00000008   0x4288             CMP      R0,R1
   \   0000000A   0xD102             BNE.N    ??HALL_GetSpeed_0
    305            s32 wAux;
    306            
    307            if( hRotorFreq_dpp == HALL_MAX_PSEUDO_SPEED)
    308            {
    309              return (HALL_MAX_SPEED);
   \   0000000C   0xF241 0x3088      MOVW     R0,#+5000
   \   00000010   0x4770             BX       LR
    310            }
    311            else
    312            {
    313              wAux = ((hRotorFreq_dpp* SAMPLING_FREQ * 10)/(65536*POLE_PAIR_NUM));
    314              return (s16)wAux;
   \                     ??HALL_GetSpeed_0:
   \   00000012   0x....             LDR.N    R1,??DataTable14_4  ;; 0x23280
   \   00000014   0x4348             MULS     R0,R1,R0
   \   00000016   0x1401             ASRS     R1,R0,#+16
   \   00000018   0xEB00 0x30D1      ADD      R0,R0,R1, LSR #+15
   \   0000001C   0x1440             ASRS     R0,R0,#+17
   \   0000001E   0x4770             BX       LR               ;; return
    315            }
    316          }
    317          
    318          /*******************************************************************************
    319          * ROUTINE Name : Hall_GetRotorFreq
    320          *
    321          * Description : This routine returns Rotor frequency with an unit that can be
    322          *               directly integrated to get the speed in the field oriented
    323          *               control loop.
    324          *
    325          * Input    : None
    326          * Output   : None
    327          * Returns  : Rotor mechanical frequency with rad/PWM period unit
    328          *             (here 2*PI rad = 0xFFFF).
    329          * Comments : Result is zero if speed is too low (glitches at start for instance)
    330          *           Excessive speed (or high freq glitches will result in a pre-defined
    331          *           value returned.
    332          * Warning : Maximum expectable accuracy depends on CKTIM: 72MHz will give the
    333          * 	    best results.
    334          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    335          s16 HALL_GetRotorFreq ( void )
    336          {
   \                     HALL_GetRotorFreq:
   \   00000000   0xB51C             PUSH     {R2-R4,LR}
    337             PeriodMeas_s PeriodMeasAux;
    338          
    339             if ( DoRollingAverage)
   \   00000002   0x....             LDR.N    R4,??DataTable14_1
   \   00000004   0x7920             LDRB     R0,[R4, #+4]
   \   00000006   0x2800             CMP      R0,#+0
   \   00000008   0xA800             ADD      R0,SP,#+0
   \   0000000A   0xD002             BEQ.N    ??HALL_GetRotorFreq_0
    340             {
    341                PeriodMeasAux = GetAvrgHallPeriod();
   \   0000000C   0x.... 0x....      BL       GetAvrgHallPeriod
   \   00000010   0xE001             B.N      ??HALL_GetRotorFreq_1
    342             }
    343             else
    344             {  // Raw period
    345                PeriodMeasAux = GetLastHallPeriod();
   \                     ??HALL_GetRotorFreq_0:
   \   00000012   0x.... 0x....      BL       GetLastHallPeriod
    346             }
    347          
    348             if (HallTimeOut == TRUE)
   \                     ??HALL_GetRotorFreq_1:
   \   00000016   0x79A0             LDRB     R0,[R4, #+6]
   \   00000018   0x2801             CMP      R0,#+1
   \   0000001A   0xBF08             IT       EQ 
   \   0000001C   0x2000             MOVEQ    R0,#+0
    349             {
    350                hRotorFreq_dpp = 0;
   \   0000001E   0xD021             BEQ.N    ??HALL_GetRotorFreq_2
    351             }
    352             else
    353             {
    354               if(PeriodMeasAux.bDirection != ERROR)
   \   00000020   0xF99D 0x0004      LDRSB    R0,[SP, #+4]
   \   00000024   0x287F             CMP      R0,#+127
   \   00000026   0xD01E             BEQ.N    ??HALL_GetRotorFreq_3
    355               //No errors have been detected during rotor speed information extrapolation          
    356               {
    357                  if ( HALL_TIMER->PSC >= HALL_MAX_RATIO )/* At start-up or very low freq */
   \   00000028   0x....             LDR.N    R1,??DataTable14_5  ;; 0x40000028
   \   0000002A   0x8809             LDRH     R1,[R1, #+0]
   \   0000002C   0xF44F 0x7248      MOV      R2,#+800
   \   00000030   0x4291             CMP      R1,R2
   \   00000032   0xBF28             IT       CS 
   \   00000034   0x2000             MOVCS    R0,#+0
    358                  {                           /* Based on current prescaler value only */
    359                     hRotorFreq_dpp = 0;
   \   00000036   0xD215             BCS.N    ??HALL_GetRotorFreq_2
    360                  }
    361                  else
    362                  {
    363                     if( PeriodMeasAux.wPeriod > MAX_PERIOD) /* Speed is too low */
   \   00000038   0x9900             LDR      R1,[SP, #+0]
   \   0000003A   0x....             LDR.N    R2,??DataTable14_6  ;; 0xb71b01
   \   0000003C   0x4291             CMP      R1,R2
   \   0000003E   0xBF28             IT       CS 
   \   00000040   0x2000             MOVCS    R0,#+0
    364                     {
    365                        hRotorFreq_dpp = 0;
   \   00000042   0xD20F             BCS.N    ??HALL_GetRotorFreq_2
    366                     }
    367                     else
    368                     {  /*Avoid u32 DIV Overflow*/
    369                        if ( PeriodMeasAux.wPeriod > (u32)SPEED_OVERFLOW )
   \   00000044   0xF645 0x52C1      MOVW     R2,#+24001
   \   00000048   0x4291             CMP      R1,R2
   \   0000004A   0xD30A             BCC.N    ??HALL_GetRotorFreq_4
    370                        {
    371                          if (HALL_GetCaptCounter()<2)// First capture must be discarded
   \   0000004C   0x8921             LDRH     R1,[R4, #+8]
   \   0000004E   0x2902             CMP      R1,#+2
   \   00000050   0xBF38             IT       CC 
   \   00000052   0x2000             MOVCC    R0,#+0
    372                          {
    373                            hRotorFreq_dpp=0;
   \   00000054   0xD306             BCC.N    ??HALL_GetRotorFreq_2
    374                          }
    375                          else                  
    376                          {
    377                             hRotorFreq_dpp = (s16)((u16) (PSEUDO_FREQ_CONV /
    378                                                                    PeriodMeasAux.wPeriod));
    379                             hRotorFreq_dpp *= PeriodMeasAux.bDirection;               
   \   00000056   0x....             LDR.N    R1,??DataTable14_7  ;; 0x6820000
   \   00000058   0x9A00             LDR      R2,[SP, #+0]
   \   0000005A   0xFBB1 0xF1F2      UDIV     R1,R1,R2
   \   0000005E   0x4348             MULS     R0,R0,R1
   \   00000060   0xE000             B.N      ??HALL_GetRotorFreq_2
    380                          }
    381                        }
    382                        else
    383                        {
    384                          hRotorFreq_dpp = HALL_MAX_PSEUDO_SPEED;
   \                     ??HALL_GetRotorFreq_4:
   \   00000062   0x....             LDR.N    R0,??DataTable14_3  ;; 0xffff8000
   \                     ??HALL_GetRotorFreq_2:
   \   00000064   0x81A0             STRH     R0,[R4, #+12]
    385                        }
    386                     }
    387                  }
    388               }          
    389             }
    390          
    391             return (hRotorFreq_dpp);
   \                     ??HALL_GetRotorFreq_3:
   \   00000066   0xF9B4 0x000C      LDRSH    R0,[R4, #+12]
   \   0000006A   0xBD16             POP      {R1,R2,R4,PC}    ;; return
    392          }
    393          
    394          
    395          /*******************************************************************************
    396          * ROUTINE Name : HALL_ClrTimeOut
    397          *
    398          * Description     : Clears the flag indicating that that informations are lost,
    399          *                   or speed is decreasing sharply.
    400          * Input           : None
    401          * Output          : Clear HallTimeOut
    402          * Return          : None
    403          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    404          void HALL_ClrTimeOut(void)
    405          {
    406             HallTimeOut = FALSE;
   \                     HALL_ClrTimeOut:
   \   00000000   0x....             LDR.N    R0,??DataTable14_1
   \   00000002   0x2100             MOVS     R1,#+0
   \   00000004   0x7181             STRB     R1,[R0, #+6]
    407          }
   \   00000006   0x4770             BX       LR               ;; return
    408          
    409          
    410          /*******************************************************************************
    411          * ROUTINE Name : HALL_IsTimedOut
    412          *
    413          * Description     : This routine indicates to the upper layer SW that Hall 
    414          *                   sensors information disappeared or timed out.
    415          * Input           : None
    416          * Output          : None
    417          * Return          : boolean, TRUE in case of Time Out
    418          * Note            : The time-out duration depends on timer pre-scaler,
    419          *                   which is variable; the time-out will be higher at low speed.
    420          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    421          bool HALL_IsTimedOut(void)
    422          {
    423             return(HallTimeOut);
   \                     HALL_IsTimedOut:
   \   00000000   0x....             LDR.N    R0,??DataTable14_1
   \   00000002   0x7980             LDRB     R0,[R0, #+6]
   \   00000004   0x4770             BX       LR               ;; return
    424          }
    425          
    426          
    427          /*******************************************************************************
    428          * ROUTINE Name : Hall_GetCaptCounter
    429          *
    430          * Description     : Gives the number of Hall sensors capture interrupts since last call
    431          *                   of the HALL_ClrCaptCounter function.
    432          * Input           : None
    433          * Output          : None
    434          * Return          : u16 integer (Roll-over is prevented in the input capture
    435          *                   routine itself).
    436          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    437          u16 HALL_GetCaptCounter(void)
    438          {
    439             return(hCaptCounter);
   \                     HALL_GetCaptCounter:
   \   00000000   0x....             LDR.N    R0,??DataTable14_1
   \   00000002   0x8900             LDRH     R0,[R0, #+8]
   \   00000004   0x4770             BX       LR               ;; return
    440          }
    441          
    442          
    443          /*******************************************************************************
    444          * ROUTINE Name : HALL_ClrCaptCounter
    445          *
    446          * Description     : Clears the variable holding the number of capture events.
    447          * Input           : None
    448          * Output          : hCaptCounter is cleared.
    449          * Return          : None
    450          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    451          void HALL_ClrCaptCounter(void)
    452          {
    453             hCaptCounter = 0;
   \                     HALL_ClrCaptCounter:
   \   00000000   0x....             LDR.N    R0,??DataTable14_1
   \   00000002   0x2100             MOVS     R1,#+0
   \   00000004   0x8101             STRH     R1,[R0, #+8]
    454          }
   \   00000006   0x4770             BX       LR               ;; return
    455          
    456          
    457          /*******************************************************************************
    458          * ROUTINE Name : GetLastHallPeriod
    459          *
    460          * Description     : returns the rotor pseudo-period based on last capture
    461          * Input           : None
    462          * Output          : None
    463          * Return          : rotor pseudo-period, as a number of CKTIM periods
    464          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    465          PeriodMeas_s GetLastHallPeriod(void)
    466          {
   \                     GetLastHallPeriod:
   \   00000000   0xB082             SUB      SP,SP,#+8
    467                PeriodMeas_s PeriodMeasAux;
    468                u8 bLastSpeedFIFO_Index;
    469          
    470             // Store current index to prevent errors if Capture occurs during processing
    471             bLastSpeedFIFO_Index = bSpeedFIFO_Index;
   \   00000002   0x....             LDR.N    R1,??DataTable14_1
   \   00000004   0x7809             LDRB     R1,[R1, #+0]
    472          
    473             // This is done assuming interval between captures is higher than time
    474             // to read the two values
    475             PeriodMeasAux.wPeriod = SensorPeriod[bLastSpeedFIFO_Index].hCapture;
   \   00000006   0xEB01 0x0241      ADD      R2,R1,R1, LSL #+1
   \   0000000A   0x0051             LSLS     R1,R2,#+1
   \   0000000C   0x....             LDR.N    R2,??DataTable14_2
   \   0000000E   0x5A8B             LDRH     R3,[R1, R2]
    476             PeriodMeasAux.wPeriod *= (SensorPeriod[bLastSpeedFIFO_Index].hPrscReg + 1);
   \   00000010   0x1889             ADDS     R1,R1,R2
   \   00000012   0x884A             LDRH     R2,[R1, #+2]
   \   00000014   0x1C52             ADDS     R2,R2,#+1
   \   00000016   0x435A             MULS     R2,R2,R3
   \   00000018   0x9200             STR      R2,[SP, #+0]
    477             
    478             PeriodMeasAux.bDirection = SensorPeriod[bLastSpeedFIFO_Index].bDirection;
   \   0000001A   0x7909             LDRB     R1,[R1, #+4]
   \   0000001C   0xF88D 0x1004      STRB     R1,[SP, #+4]
    479             return (PeriodMeasAux);
   \   00000020   0xE9DD 0x2300      LDRD     R2,R3,[SP, #+0]
   \   00000024   0xE9C0 0x2300      STRD     R2,R3,[R0, #+0]
   \   00000028   0xB002             ADD      SP,SP,#+8
   \   0000002A   0x4770             BX       LR               ;; return
    480          }
    481          
    482          
    483          /*******************************************************************************
    484          * ROUTINE Name : GetAvrgHallPeriod
    485          *
    486          * Description    : returns the rotor pseudo-period based on 4 last captures
    487          * Input          : None
    488          * Output         : None
    489          * Return         : averaged rotor pseudo-period, as a number of CKTIM periods
    490          * Side effect: the very last period acquired may not be considered for the
    491          * calculation if a capture occurs during averaging.
    492          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    493          PeriodMeas_s GetAvrgHallPeriod(void)
    494          {
   \                     GetAvrgHallPeriod:
   \   00000000   0xB4FC             PUSH     {R2-R7}
    495              u32 wFreqBuffer, wAvrgBuffer, wIndex;
    496              PeriodMeas_s PeriodMeasAux;
    497          
    498            wAvrgBuffer = 0;
   \   00000002   0x2400             MOVS     R4,#+0
    499          
    500            for ( wIndex = 0; wIndex < HALL_SPEED_FIFO_SIZE; wIndex++ )
   \   00000004   0x....             LDR.N    R1,??DataTable14_2
   \   00000006   0x2206             MOVS     R2,#+6
   \   00000008   0x....             LDR.N    R3,??DataTable14_8  ;; 0x4000000c
    501            {
    502               // Disable capture interrupts to have presc and capture of the same period
    503               HALL_TIMER->DIER &= ~TIM_IT_CC1; // NB:Std libray not used for perf issues
   \                     ??GetAvrgHallPeriod_0:
   \   0000000A   0x881D             LDRH     R5,[R3, #+0]
   \   0000000C   0xF64F 0x76FD      MOVW     R6,#+65533
   \   00000010   0x4035             ANDS     R5,R6,R5
   \   00000012   0x801D             STRH     R5,[R3, #+0]
    504               
    505               wFreqBuffer = SensorPeriod[wIndex].hCapture;
   \   00000014   0xF831 0x5B02      LDRH     R5,[R1], #+2
    506               wFreqBuffer *= (SensorPeriod[wIndex].hPrscReg + 1);
   \   00000018   0xF831 0x6B02      LDRH     R6,[R1], #+2
    507               
    508               HALL_TIMER->DIER |= TIM_IT_CC1;   // NB:Std libray not used for perf issue
   \   0000001C   0x881F             LDRH     R7,[R3, #+0]
   \   0000001E   0xF047 0x0702      ORR      R7,R7,#0x2
   \   00000022   0x801F             STRH     R7,[R3, #+0]
    509               wAvrgBuffer += wFreqBuffer;	// Sum the whole periods FIFO
   \   00000024   0x1C76             ADDS     R6,R6,#+1
   \   00000026   0xFB06 0x4405      MLA      R4,R6,R5,R4
    510               PeriodMeasAux.bDirection = SensorPeriod[wIndex].bDirection;
   \   0000002A   0xF911 0x5B02      LDRSB    R5,[R1], #+2
   \   0000002E   0xF88D 0x5004      STRB     R5,[SP, #+4]
    511            }
   \   00000032   0x1E52             SUBS     R2,R2,#+1
   \   00000034   0xD1E9             BNE.N    ??GetAvrgHallPeriod_0
    512            // Round to upper value
    513            wAvrgBuffer = (u32)(wAvrgBuffer + (HALL_SPEED_FIFO_SIZE/2)-1);  
    514            wAvrgBuffer /= HALL_SPEED_FIFO_SIZE;        // Average value	
    515          
    516            PeriodMeasAux.wPeriod = wAvrgBuffer;
   \   00000036   0x1CA1             ADDS     R1,R4,#+2
   \   00000038   0x2206             MOVS     R2,#+6
   \   0000003A   0xFBB1 0xF1F2      UDIV     R1,R1,R2
   \   0000003E   0x9100             STR      R1,[SP, #+0]
    517            
    518            return (PeriodMeasAux);
   \   00000040   0xE9DD 0x2300      LDRD     R2,R3,[SP, #+0]
   \   00000044   0xE9C0 0x2300      STRD     R2,R3,[R0, #+0]
   \   00000048   0xBCF6             POP      {R1,R2,R4-R7}
   \   0000004A   0x4770             BX       LR               ;; return
    519          }
    520          
    521          
    522          /*******************************************************************************
    523          * ROUTINE Name : HALL_StartHallFiltering
    524          *
    525          * Description : Set the flags to initiate hall speed values smoothing mechanism.
    526          * Input       : None
    527          * Output      : The result of the next capture will be copied in the whole array
    528          *               to have 1st average = last value.
    529          * Return      : None
    530          * Note: The initialization of the FIFO used to do the averaging will be done
    531          *       when the next input capture interrupt will occur.
    532          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    533          void HALL_StartHallFiltering( void )
    534          {
    535             InitRollingAverage = TRUE;
   \                     HALL_StartHallFiltering:
   \   00000000   0x....             LDR.N    R0,??DataTable14_1
   \   00000002   0x2101             MOVS     R1,#+1
   \   00000004   0x7141             STRB     R1,[R0, #+5]
    536          }
   \   00000006   0x4770             BX       LR               ;; return
    537          
    538          /*******************************************************************************
    539          * ROUTINE Name : HALL_ReadHallState
    540          *
    541          * Description : Read the GPIO Input used for Hall sensor IC and return the state  
    542          * Input       : None
    543          * Output      : None
    544          * Return      : STATE_X
    545          *
    546          *******************************************************************************/
    547          

   \                                 In section .text, align 2, keep-with-next
    548          u8 ReadHallState(void)
    549          {
   \                     ReadHallState:
   \   00000000   0xB580             PUSH     {R7,LR}
    550            u8 ReadValue;
    551          #if defined(TIMER2_HANDLES_HALL)  
    552            
    553            ReadValue = (u8)(GPIO_ReadInputData(GPIOA)) & GPIO_MSK;
    554            
    555          #elif defined(TIMER3_HANDLES_HALL)
    556            
    557            ReadValue = GPIO_ReadInputDataBit(GPIOB, GPIO_Pin_0)<<2;
    558            ReadValue |= GPIO_ReadInputDataBit(GPIOA, GPIO_Pin_6)<<1;
    559            ReadValue |= GPIO_ReadInputDataBit(GPIOA, GPIO_Pin_7);
    560          
    561          #elif defined(TIMER4_HANDLES_HALL)
    562            ReadValue = ((u8)(GPIO_ReadInputData(GPIOA))>>6) & GPIO_MSK;
    563          #endif
    564            
    565            return(ReadValue);
   \   00000002   0x....             LDR.N    R0,??DataTable14  ;; 0x40010800
   \   00000004   0x.... 0x....      BL       GPIO_ReadInputData
   \   00000008   0xF000 0x0007      AND      R0,R0,#0x7
   \   0000000C   0xBD02             POP      {R1,PC}          ;; return
    566          }
    567          
    568          /*******************************************************************************
    569          * ROUTINE Name : HALL_GetElectricalAngle
    570          *
    571          * Description : Export the variable containing the latest angle updated by IC 
    572          *               interrupt
    573          * Input       : None
    574          * Output      : None
    575          * Return      : Electrical angle s16 format
    576          *
    577          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    578          s16 HALL_GetElectricalAngle(void)
    579          {
    580            return(hElectrical_Angle);
   \                     HALL_GetElectricalAngle:
   \   00000000   0x....             LDR.N    R0,??DataTable14_1
   \   00000002   0xF9B0 0x000A      LDRSH    R0,[R0, #+10]
   \   00000006   0x4770             BX       LR               ;; return
    581          }
    582          
    583          /*******************************************************************************
    584          * ROUTINE Name : HALL_IncElectricalAngle
    585          *
    586          * Description : Increment the variable containing the rotor position information.
    587          *               This function is called at each FOC cycle for integrating 
    588          *               the speed information
    589          * Input       : None
    590          * Output      : None
    591          * Return      : Electrical angle s16 format
    592          *
    593          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    594          void HALL_IncElectricalAngle(void)
    595          { 
    596            static s16 hPrevRotorFreq;
    597           
    598            if (hRotorFreq_dpp != HALL_MAX_PSEUDO_SPEED)
   \                     HALL_IncElectricalAngle:
   \   00000000   0x....             LDR.N    R0,??DataTable14_1
   \   00000002   0xF9B0 0x100A      LDRSH    R1,[R0, #+10]
   \   00000006   0xF9B0 0x200C      LDRSH    R2,[R0, #+12]
   \   0000000A   0x....             LDR.N    R3,??DataTable14_3  ;; 0xffff8000
   \   0000000C   0x429A             CMP      R2,R3
   \   0000000E   0xBF19             ITTEE    NE 
   \   00000010   0x1851             ADDNE    R1,R2,R1
   \   00000012   0x81C2             STRHNE   R2,[R0, #+14]
   \   00000014   0x89C2             LDRHEQ   R2,[R0, #+14]
   \   00000016   0x1851             ADDEQ    R1,R2,R1
    599            {
    600              hElectrical_Angle += hRotorFreq_dpp;
    601              hPrevRotorFreq = hRotorFreq_dpp;
    602            }
    603            else
    604            {
    605              hElectrical_Angle += hPrevRotorFreq;
   \   00000018   0x8141             STRH     R1,[R0, #+10]
    606            }
    607          }
   \   0000001A   0x4770             BX       LR               ;; return

   \                                 In section .bss, align 2
   \                     bSpeedFIFO_Index:
   \   00000000                      DS8 1
   \                     bGP1_OVF_Counter:
   \   00000001                      DS8 1
   \                     RatioDec:
   \   00000002                      DS8 1
   \                     RatioInc:
   \   00000003                      DS8 1
   \                     DoRollingAverage:
   \   00000004                      DS8 1
   \                     InitRollingAverage:
   \   00000005                      DS8 1
   \                     HallTimeOut:
   \   00000006                      DS8 1
   \   00000007                      DS8 1
   \                     hCaptCounter:
   \   00000008                      DS8 2
   \   0000000A                      DS8 2
   \   0000000C                      DS8 2
   \   0000000E                      DS8 2

   \                                 In section .bss, align 4
   \                     PeriodMeas:
   \   00000000                      DS8 8
    608          
    609          /*******************************************************************************
    610          * ROUTINE Name : HALL_Init_Electrical_Angle
    611          *
    612          * Description : Read the logic level of the three Hall sensor and individuates   
    613          *               this way the position of the rotor (+/- 30). Electrical angle 
    614          *               variable is then initialized
    615          *
    616          * Input       : None
    617          * Output      : None
    618          * Return      : Electrical angle s16 format
    619          *
    620          *******************************************************************************/

   \                                 In section .text, align 4, keep-with-next
    621          void HALL_Init_Electrical_Angle(void)
    622          {
   \                     HALL_Init_Electrical_Angle:
   \   00000000   0xB580             PUSH     {R7,LR}
    623          #if (HALL_SENSORS_PLACEMENT == DEGREES_120) 
    624           switch(ReadHallState())
   \   00000002   0x....             LDR.N    R0,??DataTable14  ;; 0x40010800
   \   00000004   0x.... 0x....      BL       GPIO_ReadInputData
   \   00000008   0xF000 0x0007      AND      R0,R0,#0x7
   \   0000000C   0x1E40             SUBS     R0,R0,#+1
   \   0000000E   0x2805             CMP      R0,#+5
   \   00000010   0xD819             BHI.N    ??HALL_Init_Electrical_Angle_1
   \   00000012   0xE8DF 0xF000      TBB      [PC, R0]
   \                     ??HALL_Init_Electrical_Angle_0:
   \   00000016   0x06 0x0E          DC8      0x6,0xE,0xA,0x15
   \              0x0A 0x15    
   \   0000001A   0x03 0x12          DC8      0x3,0x12
    625           {
    626            case STATE_5:
    627              hElectrical_Angle = (s16)(S16_PHASE_SHIFT+S16_60_PHASE_SHIFT/2);
   \                     ??HALL_Init_Electrical_Angle_2:
   \   0000001C   0x....             LDR.N    R0,??DataTable14_1
   \   0000001E   0x....             LDR.N    R1,??DataTable14_9  ;; 0xffffeaab
   \   00000020   0xE010             B.N      ??HALL_Init_Electrical_Angle_3
    628              break;
    629            case STATE_1:
    630              hElectrical_Angle =(s16)(S16_PHASE_SHIFT+S16_60_PHASE_SHIFT+
    631                                                                    S16_60_PHASE_SHIFT/2);
   \                     ??HALL_Init_Electrical_Angle_4:
   \   00000022   0x....             LDR.N    R0,??DataTable14_1
   \   00000024   0xF241 0x5155      MOVW     R1,#+5461
   \   00000028   0xE00C             B.N      ??HALL_Init_Electrical_Angle_3
    632              break;
    633            case STATE_3:
    634              hElectrical_Angle =(s16)(S16_PHASE_SHIFT+S16_120_PHASE_SHIFT+
    635                                                                    S16_60_PHASE_SHIFT/2);      
   \                     ??HALL_Init_Electrical_Angle_5:
   \   0000002A   0x....             LDR.N    R0,??DataTable14_1
   \   0000002C   0xF44F 0x4180      MOV      R1,#+16384
   \   00000030   0xE008             B.N      ??HALL_Init_Electrical_Angle_3
    636              break;
    637            case STATE_2:
    638              hElectrical_Angle =(s16)(S16_PHASE_SHIFT-S16_120_PHASE_SHIFT-
    639                                                                    S16_60_PHASE_SHIFT/2);      
   \                     ??HALL_Init_Electrical_Angle_6:
   \   00000032   0x....             LDR.N    R0,??DataTable14_1
   \   00000034   0xF646 0x21AC      MOVW     R1,#+27308
   \   00000038   0xE004             B.N      ??HALL_Init_Electrical_Angle_3
    640              break;
    641            case STATE_6:
    642              hElectrical_Angle =(s16)(S16_PHASE_SHIFT-S16_60_PHASE_SHIFT-
    643                                                                    S16_60_PHASE_SHIFT/2);          
   \                     ??HALL_Init_Electrical_Angle_7:
   \   0000003A   0x....             LDR.N    R0,??DataTable14_1
   \   0000003C   0x....             LDR.N    R1,??DataTable14_10  ;; 0xffff9557
   \   0000003E   0xE001             B.N      ??HALL_Init_Electrical_Angle_3
    644              break;
    645            case STATE_4:
    646              hElectrical_Angle =(s16)(S16_PHASE_SHIFT-S16_60_PHASE_SHIFT/2);          
   \                     ??HALL_Init_Electrical_Angle_8:
   \   00000040   0x....             LDR.N    R0,??DataTable14_1
   \   00000042   0x....             LDR.N    R1,??DataTable14_11  ;; 0xffffc001
   \                     ??HALL_Init_Electrical_Angle_3:
   \   00000044   0x8141             STRH     R1,[R0, #+10]
    647              break;    
    648            default:    
    649              break;
    650            }
    651          #elif (HALL_SENSORS_PLACEMENT == DEGREES_60)
    652           switch(ReadHallState())
    653           {  
    654            case STATE_1:
    655              hElectrical_Angle =(s16)(S16_PHASE_SHIFT+S16_60_PHASE_SHIFT/2);
    656              break;
    657            case STATE_3:
    658              hElectrical_Angle =(s16)(S16_PHASE_SHIFT+S16_60_PHASE_SHIFT+
    659                                                                    S16_60_PHASE_SHIFT/2);
    660              break;
    661            case STATE_7:
    662              hElectrical_Angle =(s16)(S16_PHASE_SHIFT+S16_120_PHASE_SHIFT+
    663                                                                    S16_60_PHASE_SHIFT/2);      
    664              break;
    665            case STATE_6:
    666              hElectrical_Angle =(s16)(S16_PHASE_SHIFT-S16_120_PHASE_SHIFT-
    667                                                                    S16_60_PHASE_SHIFT/2);      
    668              break;
    669            case STATE_4:
    670              hElectrical_Angle =(s16)(S16_PHASE_SHIFT-S16_60_PHASE_SHIFT-
    671                                                                    S16_60_PHASE_SHIFT/2);          
    672              break;
    673            case STATE_0:
    674              hElectrical_Angle =(s16)(S16_PHASE_SHIFT-S16_60_PHASE_SHIFT/2);          
    675              break;    
    676            default:    
    677              break;
    678            }
    679          #endif
    680          }
   \                     ??HALL_Init_Electrical_Angle_1:
   \   00000046   0xBD01             POP      {R0,PC}          ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14:
   \   00000000   0x40010800         DC32     0x40010800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_1:
   \   00000000   0x........         DC32     bSpeedFIFO_Index

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_2:
   \   00000000   0x........         DC32     SensorPeriod

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_3:
   \   00000000   0xFFFF8000         DC32     0xffff8000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_4:
   \   00000000   0x00023280         DC32     0x23280

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_5:
   \   00000000   0x40000028         DC32     0x40000028

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_6:
   \   00000000   0x00B71B01         DC32     0xb71b01

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_7:
   \   00000000   0x06820000         DC32     0x6820000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_8:
   \   00000000   0x4000000C         DC32     0x4000000c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_9:
   \   00000000   0xFFFFEAAB         DC32     0xffffeaab

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_10:
   \   00000000   0xFFFF9557         DC32     0xffff9557

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_11:
   \   00000000   0xFFFFC001         DC32     0xffffc001
    681          
    682          /*******************************************************************************
    683          * Function Name  : TIMx_IRQHandler
    684          * Description    : This function handles both the capture event and Update event 
    685          *                  interrupt handling the hall sensors signal period measurement
    686          *                  
    687          *                  - On 'CAPTURE' event case:
    688          *                    The spinning direction is extracted
    689          *                    The electrical angle is updated (synchronized)
    690          *                    If the average is initialized, the last captured measure is
    691          *                    copied into the whole array.
    692          *                    Period captures are managed as following:
    693          *                    If too low, the clock prescaler is decreased for next measure
    694          *                    If too high (ie there was overflows), the result is
    695          *                    re-computed as if there was no overflow and the prescaler is
    696          *                    increased to avoid overflows during the next capture
    697          *                   
    698          *                  - On 'UPDATE' event case:
    699          *                    This function handles the overflow of the timer handling
    700          *                    the hall sensors signal period measurement.
    701          * Input          : 
    702          *                  - On 'CAPTURE' event case:
    703          *                    None
    704          *                   
    705          *                  - On 'UPDATE' event case: 
    706          *                    None
    707          *
    708          * Output         : 
    709          *                  - On 'CAPTURE' event case:
    710          *                   Updates the array holding the 4 latest period measures, reset
    711          *                   the overflow counter and update the clock prescaler to
    712          *                   optimize the accuracy of the measurement.
    713          *                   
    714          *                  - On 'UPDATE' event case:
    715          *                    Updates a Counter of overflows, handled and reset when next
    716          *                    capture occurs. 
    717          *
    718          * Return         : None (Interrupt Service routine)
    719          *******************************************************************************/
    720          #if (defined HALL_SENSORS || defined VIEW_HALL_FEEDBACK)
    721          #if defined(TIMER2_HANDLES_HALL)
    722          void TIM2_IRQHandler(void)
    723          #elif defined(TIMER3_HANDLES_HALL)
    724          void TIM3_IRQHandler(void)
    725          #else // TIMER4_HANDLES_HALL
    726          void TIM4_IRQHandler(void)
    727          #endif
    728          
    729          {
    730            static u8  bHallState; 
    731            u8 bPrevHallState;
    732          
    733          // Check for the source of TIMx int - Capture or Update Event - 
    734            if ( TIM_GetFlagStatus(HALL_TIMER, TIM_FLAG_Update) == RESET )
    735            {
    736              // A capture event generated this interrupt
    737              bPrevHallState = bHallState;
    738              bHallState = ReadHallState();
    739          #if (HALL_SENSORS_PLACEMENT == DEGREES_120)    
    740              switch(bHallState)
    741              {
    742                case STATE_5:
    743                  if (bPrevHallState == STATE_5)
    744                  {
    745          	 //a speed reversal occured 
    746                   if(bSpeed<0)
    747                   {
    748                     bSpeed = POSITIVE_SWAP;
    749                   }
    750                   else
    751                   {
    752                     bSpeed = NEGATIVE_SWAP;
    753                   }
    754                  }
    755                  else   
    756                    if (bPrevHallState == STATE_6)
    757                    {
    758                     bSpeed = POSITIVE;
    759                    }
    760                    else 
    761                      if (bPrevHallState == STATE_3)
    762                      {
    763                        bSpeed = NEGATIVE;
    764                      }
    765          		// Update angle
    766                  if(bSpeed<0)
    767                  {
    768                    hElectrical_Angle = (s16)(S16_PHASE_SHIFT+S16_60_PHASE_SHIFT);
    769                  }
    770                  else if(bSpeed!= ERROR)
    771                  {
    772                    hElectrical_Angle = S16_PHASE_SHIFT;  
    773                  }
    774                  break;
    775                       
    776              case STATE_3:
    777                  if (bPrevHallState == STATE_3)
    778                  {
    779          		 //a speed reversal occured
    780                   if(bSpeed<0)
    781                   {
    782                     bSpeed = POSITIVE_SWAP;
    783                   }
    784                   else
    785                   {
    786                     bSpeed = NEGATIVE_SWAP;
    787                   }
    788                  }
    789                  else
    790                    if (bPrevHallState == STATE_5)
    791                    {
    792                     bSpeed = POSITIVE;
    793                    }
    794                    else 
    795                      if (bPrevHallState == STATE_6)
    796                      {
    797                        bSpeed = NEGATIVE;
    798                      }
    799          		// Update of the electrical angle
    800                  if(bSpeed<0)
    801                  {
    802                    hElectrical_Angle = (s16)(S16_PHASE_SHIFT+S16_120_PHASE_SHIFT+
    803                                                                      S16_60_PHASE_SHIFT);
    804                  }
    805                  else if(bSpeed!= ERROR)
    806                  {
    807                    hElectrical_Angle =(s16)(S16_PHASE_SHIFT + S16_120_PHASE_SHIFT);
    808                  }
    809                  break;  
    810                
    811                case STATE_6: 
    812                  if (bPrevHallState == STATE_6)
    813                  {
    814                   if(bSpeed<0)
    815                   {
    816                     bSpeed = POSITIVE_SWAP;
    817                   }
    818                   else
    819                   {
    820                     bSpeed = NEGATIVE_SWAP;
    821                   }
    822                  }
    823                  
    824                  if (bPrevHallState == STATE_3)
    825                  {
    826                   bSpeed = POSITIVE; 
    827                  }
    828                  else 
    829                    if (bPrevHallState == STATE_5)
    830                    {
    831                      bSpeed = NEGATIVE;
    832                    }  
    833                  if(bSpeed<0)
    834                  {
    835                    hElectrical_Angle =(s16)(S16_PHASE_SHIFT - S16_60_PHASE_SHIFT);  
    836                  }
    837                  else if(bSpeed!= ERROR)
    838                  {
    839                    hElectrical_Angle =(s16)(S16_PHASE_SHIFT - S16_120_PHASE_SHIFT); 
    840                  }
    841                  break;
    842                  
    843                default:
    844                  bSpeed = ERROR;
    845                  break;
    846              }
    847          #elif (HALL_SENSORS_PLACEMENT == DEGREES_60)    
    848              switch(bHallState)
    849              {
    850                case STATE_3:
    851                  if (bPrevHallState == STATE_3)
    852                  {
    853                   if(bSpeed<0)
    854                   {
    855                     bSpeed = POSITIVE_SWAP;
    856                   }
    857                   else
    858                   {
    859                     bSpeed = NEGATIVE_SWAP;
    860                   }
    861                  }
    862                  else          
    863                    if (bPrevHallState == STATE_0)
    864                    {
    865                     bSpeed = POSITIVE;
    866                    }
    867                    else 
    868                      if (bPrevHallState == STATE_6)
    869                      {
    870                        bSpeed = NEGATIVE;              
    871                      }
    872                  if(bSpeed<0)
    873                  {
    874                    hElectrical_Angle = (s16)(S16_PHASE_SHIFT+S16_120_PHASE_SHIFT);
    875                  }
    876                  else if(bSpeed!= ERROR)
    877                  {
    878                    hElectrical_Angle = (s16)(S16_PHASE_SHIFT+S16_60_PHASE_SHIFT);
    879                  }
    880                  break;
    881                       
    882                case STATE_6:
    883                  if (bPrevHallState == STATE_6)
    884                  {
    885                   if(bSpeed<0)
    886                   {
    887                     bSpeed = POSITIVE_SWAP;
    888                   }
    889                   else
    890                   {
    891                     bSpeed = NEGATIVE_SWAP;
    892                   }
    893                  } 
    894                  else
    895                    if (bPrevHallState == STATE_3)
    896                    {
    897                     bSpeed = POSITIVE;           
    898                    }
    899                    else 
    900                      if (bPrevHallState == STATE_0)
    901                      {
    902                        bSpeed = NEGATIVE;
    903                      }
    904                  if(bSpeed<0)
    905                  {
    906                    hElectrical_Angle = (s16)(S16_PHASE_SHIFT-S16_120_PHASE_SHIFT);
    907                  }
    908                  else if(bSpeed!= ERROR)
    909                  {
    910                    hElectrical_Angle =(s16)(S16_PHASE_SHIFT + S16_120_PHASE_SHIFT+
    911                                                                      S16_60_PHASE_SHIFT);
    912                  }
    913                  break;  
    914                
    915                case STATE_0:
    916                  if (bPrevHallState == STATE_0)
    917                  {
    918                   if(bSpeed<0)
    919                   {
    920                     bSpeed = POSITIVE_SWAP;
    921                   }
    922                   else
    923                   {
    924                     bSpeed = NEGATIVE_SWAP;
    925                   }
    926                  } 
    927                  else
    928                    if (bPrevHallState == STATE_6)
    929                    {
    930                     bSpeed = POSITIVE;
    931                    }
    932                    else 
    933                      if (bPrevHallState == STATE_3)
    934                      {
    935                        bSpeed = NEGATIVE;
    936                      }
    937                  
    938                  if(bSpeed<0)
    939                  {
    940                    hElectrical_Angle =(s16)(S16_PHASE_SHIFT );  
    941                  }
    942                  else if(bSpeed!= ERROR)
    943                  {
    944                    hElectrical_Angle =(s16)(S16_PHASE_SHIFT - S16_60_PHASE_SHIFT);  
    945                  }                      
    946                  break;
    947                  
    948                default:
    949                  bSpeed = ERROR;
    950                  break;
    951              }
    952          #endif
    953             // A capture event occured, it clears the flag  	
    954          	TIM_ClearFlag(HALL_TIMER, TIM_FLAG_CC1);
    955             
    956             // used for discarding first capture
    957             if (hCaptCounter < U16_MAX)
    958             {
    959                hCaptCounter++;
    960             }
    961          
    962             // Compute new array index
    963             if (bSpeedFIFO_Index != HALL_SPEED_FIFO_SIZE-1)
    964             {
    965                bSpeedFIFO_Index++;
    966             }
    967             else
    968             {
    969                bSpeedFIFO_Index = 0;
    970             }
    971          
    972             //Timeout Flag is cleared when receiving an IC
    973             HALL_ClrTimeOut();
    974             
    975             // Store the latest speed acquisition
    976             if (bGP1_OVF_Counter != 0)	// There was counter overflow before capture
    977             {
    978                  u32 wCaptBuf;
    979                  u16 hPrscBuf;
    980          
    981                wCaptBuf = (u32)TIM_GetCapture1(HALL_TIMER);        
    982                
    983                hPrscBuf = HALL_TIMER->PSC;
    984          
    985                while (bGP1_OVF_Counter != 0)
    986                {
    987                   wCaptBuf += 0x10000uL;// Compute the real captured value (> 16-bit)
    988                   bGP1_OVF_Counter--;
    989                   // OVF Counter is 8-bit and Capt is 16-bit, thus max CaptBuf is 24-bits
    990                }
    991                while(wCaptBuf > U16_MAX)
    992                {
    993                   wCaptBuf /= 2;		// Make it fit 16-bit using virtual prescaler
    994                   // Reduced resolution not a problem since result just slightly < 16-bit
    995                   hPrscBuf = (hPrscBuf * 2) + 1;
    996                   if (hPrscBuf > U16_MAX/2) // Avoid Prsc overflow
    997                   {
    998                      hPrscBuf = U16_MAX;
    999                      wCaptBuf = U16_MAX;
   1000                   }
   1001                }
   1002                SensorPeriod[bSpeedFIFO_Index].hCapture = wCaptBuf;
   1003                SensorPeriod[bSpeedFIFO_Index].hPrscReg = hPrscBuf;
   1004                SensorPeriod[bSpeedFIFO_Index].bDirection = bSpeed;
   1005                if (RatioInc)
   1006                {
   1007                   RatioInc = FALSE;	// Previous capture caused overflow
   1008                   // Don't change prescaler (delay due to preload/update mechanism)
   1009                }
   1010                else
   1011                {
   1012                   if ((HALL_TIMER->PSC) < HALL_MAX_RATIO) // Avoid OVF w/ very low freq
   1013                   {
   1014                      (HALL_TIMER->PSC)++; // To avoid OVF during speed decrease
   1015                      RatioInc = TRUE;	  // new prsc value updated at next capture only
   1016                   }
   1017                }
   1018             }
   1019             else		// No counter overflow
   1020             {
   1021                u16 hHighSpeedCapture, hClockPrescaler;   
   1022          
   1023                hHighSpeedCapture = (u32)TIM_GetCapture1(HALL_TIMER);
   1024                  
   1025                SensorPeriod[bSpeedFIFO_Index].hCapture = hHighSpeedCapture;
   1026                SensorPeriod[bSpeedFIFO_Index].bDirection = bSpeed;
   1027                // Store prescaler directly or incremented if value changed on last capt
   1028                hClockPrescaler = HALL_TIMER->PSC;
   1029          
   1030                // If prsc preload reduced in last capture, store current register + 1
   1031                if (RatioDec)  // and don't decrease it again
   1032                {
   1033                   SensorPeriod[bSpeedFIFO_Index].hPrscReg = (hClockPrescaler)+1;
   1034                   RatioDec = FALSE;
   1035                }
   1036                else  // If prescaler was not modified on previous capture
   1037                {
   1038                   if (hHighSpeedCapture >= LOW_RES_THRESHOLD)// If capture range correct
   1039                   {
   1040                      SensorPeriod[bSpeedFIFO_Index].hPrscReg = hClockPrescaler;
   1041                   }
   1042                   else
   1043                   {
   1044                      if(HALL_TIMER->PSC == 0) // or prescaler cannot be further reduced
   1045                      {
   1046                         SensorPeriod[bSpeedFIFO_Index].hPrscReg = hClockPrescaler;
   1047                      }
   1048                      else  // The prescaler needs to be modified to optimize the accuracy
   1049                      {
   1050                         SensorPeriod[bSpeedFIFO_Index].hPrscReg = hClockPrescaler;
   1051                         (HALL_TIMER->PSC)--;	// Increase accuracy by decreasing prsc
   1052                         // Avoid decrementing again in next capt.(register preload delay)
   1053                         RatioDec = TRUE;
   1054                      }
   1055                   }
   1056                }
   1057             }
   1058              
   1059             if (InitRollingAverage)
   1060             {
   1061                  u16 hCaptBuf, hPrscBuf;
   1062                  s8 bSpeedAux;
   1063                  u32 wIndex;
   1064                // Read last captured value and copy it into the whole array
   1065                hCaptBuf = SensorPeriod[bSpeedFIFO_Index].hCapture;
   1066                hPrscBuf = SensorPeriod[bSpeedFIFO_Index].hPrscReg;
   1067                bSpeedAux = SensorPeriod[bSpeedFIFO_Index].bDirection;
   1068                
   1069                for (wIndex = 0; wIndex != HALL_SPEED_FIFO_SIZE-1; wIndex++)
   1070                {
   1071                   SensorPeriod[wIndex].hCapture = hCaptBuf;
   1072                   SensorPeriod[wIndex].hPrscReg = hPrscBuf;
   1073                   SensorPeriod[wIndex].bDirection = bSpeedAux;
   1074                }
   1075                InitRollingAverage = FALSE;
   1076                // Starting from now, the values returned by MTC_GetRotorFreq are averaged
   1077                DoRollingAverage = TRUE;
   1078              }
   1079             
   1080            //Update Rotor Frequency Computation
   1081             hRotorFreq_dpp = HALL_GetRotorFreq();
   1082            
   1083            }
   1084            else 
   1085            {
   1086              TIM_ClearFlag(HALL_TIMER, TIM_FLAG_Update);  
   1087            	// an update event occured for this interrupt request generation
   1088              if (bGP1_OVF_Counter < U8_MAX)
   1089              {
   1090                 bGP1_OVF_Counter++;
   1091              }
   1092            
   1093              if (bGP1_OVF_Counter >= HALL_MAX_OVERFLOWS)
   1094              {
   1095                 HallTimeOut = TRUE;
   1096                 hRotorFreq_dpp = 0;
   1097              }    
   1098            }
   1099          }
   1100          
   1101          #endif // HALL_SENSORS defined
   1102          
   1103          /******************* (C) COPYRIGHT 2008 STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       24  GetAvrgHallPeriod
        8  GetLastHallPeriod
        0  HALL_ClrCaptCounter
        0  HALL_ClrTimeOut
        0  HALL_GetCaptCounter
        0  HALL_GetElectricalAngle
       16  HALL_GetRotorFreq
             16 -> GetAvrgHallPeriod
             16 -> GetLastHallPeriod
        0  HALL_GetSpeed
       40  HALL_HallTimerInit
             40 -> GPIO_Init
             40 -> GPIO_StructInit
             40 -> NVIC_Init
             40 -> RCC_APB1PeriphClockCmd
             40 -> RCC_APB2PeriphClockCmd
             40 -> TIM_ClearFlag
             40 -> TIM_Cmd
             40 -> TIM_DeInit
             40 -> TIM_ICInit
             40 -> TIM_ICStructInit
             40 -> TIM_ITConfig
             40 -> TIM_InternalClockConfig
             40 -> TIM_PrescalerConfig
             40 -> TIM_SelectHallSensor
             40 -> TIM_SelectInputTrigger
             40 -> TIM_SelectSlaveMode
             40 -> TIM_SetCounter
             40 -> TIM_TimeBaseInit
             40 -> TIM_TimeBaseStructInit
             40 -> TIM_UpdateRequestConfig
        0  HALL_IncElectricalAngle
       16  HALL_InitHallMeasure
             16 -> TIM_Cmd
              0 -> TIM_ITConfig
             16 -> TIM_ITConfig
             16 -> TIM_SetCounter
        8  HALL_Init_Electrical_Angle
              8 -> GPIO_ReadInputData
        0  HALL_IsTimedOut
        0  HALL_StartHallFiltering
        8  ReadHallState
              8 -> GPIO_ReadInputData


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable14
       4  ??DataTable14_1
       4  ??DataTable14_10
       4  ??DataTable14_11
       4  ??DataTable14_2
       4  ??DataTable14_3
       4  ??DataTable14_4
       4  ??DataTable14_5
       4  ??DataTable14_6
       4  ??DataTable14_7
       4  ??DataTable14_8
       4  ??DataTable14_9
      76  GetAvrgHallPeriod
      44  GetLastHallPeriod
       8  HALL_ClrCaptCounter
       8  HALL_ClrTimeOut
       6  HALL_GetCaptCounter
       8  HALL_GetElectricalAngle
     108  HALL_GetRotorFreq
      32  HALL_GetSpeed
     270  HALL_HallTimerInit
      28  HALL_IncElectricalAngle
     140  HALL_InitHallMeasure
      72  HALL_Init_Electrical_Angle
       6  HALL_IsTimedOut
       8  HALL_StartHallFiltering
       8  PeriodMeas
      14  ReadHallState
      36  SensorPeriod
      16  bSpeedFIFO_Index
          bGP1_OVF_Counter
          RatioDec
          RatioInc
          DoRollingAverage
          InitRollingAverage
          HallTimeOut
          hCaptCounter
          hElectrical_Angle
          hRotorFreq_dpp
          hPrevRotorFreq

 
  60 bytes in section .bss
 876 bytes in section .text
 
 876 bytes of CODE memory
  60 bytes of DATA memory

Errors: none
Warnings: 4
